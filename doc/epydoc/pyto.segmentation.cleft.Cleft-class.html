<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>pyto.segmentation.cleft.Cleft</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pyto-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            >Pyto</th>
          </tr></table></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="pyto-module.html">Package&nbsp;pyto</a> ::
        <a href="pyto.segmentation-module.html">Package&nbsp;segmentation</a> ::
        <a href="pyto.segmentation.cleft-module.html">Module&nbsp;cleft</a> ::
        Class&nbsp;Cleft
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="pyto.segmentation.cleft.Cleft-class.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== CLASS DESCRIPTION ==================== -->
<h1 class="epydoc">Class Cleft</h1><p class="nomargin-top"><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft">source&nbsp;code</a></span></p>
<center>
<center>  <map id="uml_class_diagram_for_pyto_seg_3" name="uml_class_diagram_for_pyto_seg_3">
<area shape="rect" id="node1_64" href="pyto.segmentation.cleft.Cleft-class.html#__init__" title="Sets attributes from arguments." alt="" coords="18,1319,1147,1339"/>
<area shape="rect" id="node1_65" href="pyto.segmentation.cleft.Cleft-class.html#setCleftIds" title="Sets boundary, cleft and all ids as attributes, in addition to whatever &#160;else super does." alt="" coords="18,1339,1147,1359"/>
<area shape="rect" id="node1_66" href="pyto.segmentation.cleft.Cleft-class.html#getWidth" title="Calculates the width and the orientation of the cleft (direction of the &#160;width vector)." alt="" coords="18,1359,1147,1379"/>
<area shape="rect" id="node1_67" href="pyto.segmentation.cleft.Cleft-class.html#getBoundaryDistances" title="For each boundary element contacting cleft (boundary edge), finds the &#160;position of the closest element on the other boundary and calculates the &#160;distance between them." alt="" coords="18,1379,1147,1399"/>
<area shape="rect" id="node1_68" href="pyto.segmentation.cleft.Cleft-class.html#makeLayers" title="Makes cleft and boundary layers." alt="" coords="18,1399,1147,1419"/>
<area shape="rect" id="node1_69" href="pyto.segmentation.cleft.Cleft-class.html#adjustToRegions" title="Adjusts self.data to correspond to regions.data." alt="" coords="18,1419,1147,1439"/>
<area shape="rect" id="node1_70" href="pyto.segmentation.cleft.Cleft-class.html#makeColumns" title="Segments cleft to columns, that is segments perpendicular to cleft &#160;layers." alt="" coords="18,1439,1147,1459"/>
<area shape="rect" id="node1_71" href="pyto.segmentation.cleft.Cleft-class.html#parametrizeLayers" title="Parametrizes layers, that is puts a coordinate system on layer&#45;like segments." alt="" coords="18,1459,1147,1479"/>
<area shape="rect" id="node1_72" href="pyto.segmentation.cleft.Cleft-class.html#pickCenter" title="Returns coordinates of the center of segment specified by arg id_." alt="" coords="18,1479,1147,1499"/>
<area shape="rect" id="node1_73" href="pyto.segmentation.cleft.Cleft-class.html#pickLayerCenters" title="Returns coordinates of &#39;centers&#39;of all segments specified by arg ids." alt="" coords="18,1499,1147,1519"/>
<area shape="rect" id="node1_74" href="pyto.segmentation.cleft.Cleft-class.html#read" title="Reads segmented image (label filed) from a file and sets required ids." alt="" coords="18,1519,1147,1539"/>
<area shape="rect" id="node1" href="pyto.segmentation.cleft.Cleft-class.html" title="Important attributes:" alt="" coords="5,1287,1159,1545"/>
<area shape="rect" id="node2_75" href="pyto.segmentation.segment.Segment-class.html#setData" title="Sets data and the attributes determined from data." alt="" coords="314,961,853,981"/>
<area shape="rect" id="node2_76" href="pyto.segmentation.segment.Segment-class.html#setDefaults" title="Sets structure elements and _labelMask attributes derived from (the shape &#160;and the type of) data that haven&#39;t been set already to their default &#160;values." alt="" coords="314,981,853,1001"/>
<area shape="rect" id="node2_77" href="pyto.segmentation.segment.Segment-class.html#setSurfaceStructEl" title="Not used anymore." alt="" coords="314,1001,853,1021"/>
<area shape="rect" id="node2_78" href="pyto.segmentation.segment.Segment-class.html#parseInput" title="Returns data, ids and update." alt="" coords="314,1021,853,1041"/>
<area shape="rect" id="node2_79" href="pyto.segmentation.segment.Segment-class.html#removeIdFromBound" title="Removes ids from boundaryIds, freeIds and _free." alt="" coords="314,1041,853,1061"/>
<area shape="rect" id="node2_80" href="pyto.segmentation.segment.Segment-class.html#setProperties" title="Sets attributes of this instance from (arg) properties." alt="" coords="314,1061,853,1081"/>
<area shape="rect" id="node2_81" href="pyto.segmentation.segment.Segment-class.html#findNonUnique" title="Finds segments that are disconnected and segments that do not exist (id in &#160;self.ids but have no elements) and returns their ids." alt="" coords="314,1081,853,1101"/>
<area shape="rect" id="node2_82" href="pyto.segmentation.segment.Segment-class.html#clean" title="Makes self.data and self.ids consistent by removing segments self.data that are not in self.ids, and removing ids from self.ids corresponding to &#160;non&#45;existing segments." alt="" coords="314,1101,853,1121"/>
<area shape="rect" id="node2_83" href="pyto.segmentation.segment.Segment-class.html#remove" title="Removes segments labeled by (elements of) ids, by replacing the &#160;corresponding elements of data by value." alt="" coords="314,1121,853,1141"/>
<area shape="rect" id="node2_84" href="pyto.segmentation.segment.Segment-class.html#keep" title="Keeps only the segments labeled by elements of ids." alt="" coords="314,1141,853,1161"/>
<area shape="rect" id="node2_85" href="pyto.segmentation.segment.Segment-class.html#add" title="Adds new segments to the existing data." alt="" coords="314,1161,853,1181"/>
<area shape="rect" id="node2_86" href="pyto.segmentation.segment.Segment-class.html#reorder" title="Changes ids of segments according to the order, or orderes ids from 1 up &#160;without gaps if order is not given." alt="" coords="314,1181,853,1201"/>
<area shape="rect" id="node2_87" href="pyto.segmentation.segment.Segment-class.html#shiftIds" title="Shifts all (positive) ids of segments by (arg) shift." alt="" coords="314,1201,853,1221"/>
<area shape="rect" id="node2_88" href="pyto.segmentation.segment.Segment-class.html#distanceFromOrigin" title="For each element of specified segments (keys of arg origins) calculates &#160;distance from the origin of the segment the element belongs to." alt="" coords="314,1241,853,1261"/>
<area shape="rect" id="node2" href="pyto.segmentation.segment.Segment-class.html" title="Manipulations and analysis of segmented images (label fields)." alt="" coords="302,929,865,1268"/>
<area shape="rect" id="node3_89" href="pyto.core.image.Image-class.html#ndim" title="Dimensionality of data" alt="" coords="127,29,1038,49"/>
<area shape="rect" id="node3_90" href="pyto.core.image.Image-class.html#offset" title="Position of the origin in respect to some reference" alt="" coords="127,49,1038,69"/>
<area shape="rect" id="node3_91" href="pyto.core.image.Image-class.html#totalOffset" title="Total offset, that is a sum of self.offset and the start positions of &#160;self.inset." alt="" coords="127,69,1038,89"/>
<area shape="rect" id="node3_92" href="pyto.core.image.Image-class.html#inset" title="(list of slice objects) a current view of self.data array in respect to the underlying base reference array." alt="" coords="127,89,1038,109"/>
<area shape="rect" id="node3_93" href="pyto.core.image.Image-class.html#fullInset" title="Full inset that underlies current self.data." alt="" coords="127,109,1038,129"/>
<area shape="rect" id="node3_94" href="pyto.core.image.Image-class.html#fullData" title="Full size data array" alt="" coords="127,129,1038,149"/>
<area shape="rect" id="node3_95" href="pyto.core.image.Image-class.html#tile" title="Use the current instance (image) as a tile (pattern) to make a (bigger) &#160;image in arbitrary dimensions." alt="" coords="127,152,1038,172"/>
<area shape="rect" id="node3_96" href="pyto.core.image.Image-class.html#getNdim" title="Gets ndim from self.data, or if the data does not exists returns &#160;self._ndim." alt="" coords="127,172,1038,192"/>
<area shape="rect" id="node3_97" href="pyto.core.image.Image-class.html#setNdim" title="Sets self._ndim." alt="" coords="127,192,1038,212"/>
<area shape="rect" id="node3_98" href="pyto.core.image.Image-class.html#setOffset" title="Sets offset of &#160;(ndarray) self.offset." alt="" coords="127,212,1038,232"/>
<area shape="rect" id="node3_99" href="pyto.core.image.Image-class.html#getOffset" title="Returns current offset value." alt="" coords="127,232,1038,252"/>
<area shape="rect" id="node3_100" href="pyto.core.image.Image-class.html#getTotalOffset" title="Returns total offset, which is a sum of self.offset and the start positions of self.inset." alt="" coords="127,252,1038,272"/>
<area shape="rect" id="node3_101" href="pyto.core.image.Image-class.html#setInset" title="Sets inset for self.data (does not modify self.data)." alt="" coords="127,272,1038,292"/>
<area shape="rect" id="node3_102" href="pyto.core.image.Image-class.html#getInset" title="Returns inset position as a list of slice objects." alt="" coords="127,292,1038,312"/>
<area shape="rect" id="node3_103" href="pyto.core.image.Image-class.html#relativeToAbsoluteInset" title="Converts relative inset (in respect to the current inset (self.inset)) to &#160;an absolute inset." alt="" coords="127,312,1038,332"/>
<area shape="rect" id="node3_104" href="pyto.core.image.Image-class.html#absoluteToRelativeInset" title="Converts given absolute inset into inset relative to the current inset &#160;(self.inset)." alt="" coords="127,332,1038,352"/>
<area shape="rect" id="node3_105" href="pyto.core.image.Image-class.html#setFullInset" title="Sets full inset for self.data (does not modify self.data)." alt="" coords="127,352,1038,372"/>
<area shape="rect" id="node3_106" href="pyto.core.image.Image-class.html#getFullInset" title="Returns a previously defined inset (list of slice objects) of a full&#45;size &#160;array underlying (the current view) of self.data." alt="" coords="127,372,1038,392"/>
<area shape="rect" id="node3_107" href="pyto.core.image.Image-class.html#getFullData" title="Returns a previously defined full&#45;size array underlying (the current view &#160;of) self.data." alt="" coords="127,392,1038,412"/>
<area shape="rect" id="node3_108" href="pyto.core.image.Image-class.html#write" title="Writes image to a file in em, mrc or raw format." alt="" coords="127,432,1038,452"/>
<area shape="rect" id="node3" href="pyto.core.image.Image-class.html" title="Methods for creating new images: &#45; tile: tile current image to get a bigger one" alt="" coords="115,5,1049,459"/>
<area shape="rect" id="node4_109" href="pyto.segmentation.labels.Labels-class.html#maxId" title="Maximum id" alt="" coords="251,502,914,522"/>
<area shape="rect" id="node4_110" href="pyto.segmentation.labels.Labels-class.html#contactStructElConn" title="Contact structuring element connectivity, default 1" alt="" coords="251,522,914,542"/>
<area shape="rect" id="node4_111" href="pyto.segmentation.labels.Labels-class.html#contactStructEl" title="Contact structuring element, default connectivity 1" alt="" coords="251,542,914,562"/>
<area shape="rect" id="node4_112" href="pyto.segmentation.labels.Labels-class.html#countStructElConn" title="Count structuring element connectivity, default ndim" alt="" coords="251,562,914,582"/>
<area shape="rect" id="node4_113" href="pyto.segmentation.labels.Labels-class.html#countStructEl" title="Count structuring element, default connectivity ndim" alt="" coords="251,582,914,602"/>
<area shape="rect" id="node4_114" href="pyto.segmentation.labels.Labels-class.html#makeInset" title="Finds the smallest inset that contains all elements of self.data labeled by ids (or self.ids if ids is None)." alt="" coords="251,605,914,625"/>
<area shape="rect" id="node4_115" href="pyto.segmentation.labels.Labels-class.html#findInset" title="Returns the smallest inset (list of slice objects of length self.ndim) that contains all elements of self.data labeled by ids (or self.ids if ids is &#160;None)." alt="" coords="251,625,914,645"/>
<area shape="rect" id="node4_116" href="pyto.segmentation.labels.Labels-class.html#setIds" title="Sets id and related attributes: self.ids (ndarray of flattened ids), &#160;self.originalIds (self.maxId, self.nextId and self.n)." alt="" coords="251,645,914,665"/>
<area shape="rect" id="node4_117" href="pyto.segmentation.labels.Labels-class.html#extractIds" title="Finds segment ids, that is positive unique elements of data array." alt="" coords="251,665,914,685"/>
<area shape="rect" id="node4_118" href="pyto.segmentation.labels.Labels-class.html#getMaxId" title="Maximum id" alt="" coords="251,685,914,705"/>
<area shape="rect" id="node4_119" href="pyto.segmentation.labels.Labels-class.html#setMaxId" title="Doesn&#39;t do anything, needed for compatibility with super." alt="" coords="251,705,914,725"/>
<area shape="rect" id="node4_120" href="pyto.segmentation.labels.Labels-class.html#restrict" title="Removes (sets to 0) data elements of this instance that have one of the &#160;specified ids and where mask.data is 0 (if arg update is True)." alt="" coords="251,725,914,745"/>
<area shape="rect" id="node4_121" href="pyto.segmentation.labels.Labels-class.html#orderByBoundaries" title="Orders segments both here and in the contacts object by ids of contacted &#160;boundaries." alt="" coords="251,745,914,765"/>
<area shape="rect" id="node4_122" href="pyto.segmentation.labels.Labels-class.html#orderIdsByBoundaries" title="Orders self.ids according to the ids of contacted boundaries." alt="" coords="251,765,914,785"/>
<area shape="rect" id="node4_123" href="pyto.segmentation.labels.Labels-class.html#orderByValues" title="Orders segments, that is changes their ids according to values." alt="" coords="251,785,914,805"/>
<area shape="rect" id="node4_124" href="pyto.segmentation.labels.Labels-class.html#orderIdsByValues" title="Orders ids by values." alt="" coords="251,805,914,825"/>
<area shape="rect" id="node4_125" href="pyto.segmentation.labels.Labels-class.html#setStructEl" title="Sets or updates structuring element (self.structEl)." alt="" coords="251,825,914,845"/>
<area shape="rect" id="node4_126" href="pyto.segmentation.labels.Labels-class.html#setContactStructElConn" title="Sets self._contactStructElConn." alt="" coords="251,845,914,865"/>
<area shape="rect" id="node4_127" href="pyto.segmentation.labels.Labels-class.html#magnify" title="Magnifies (increases the size of) the data array (self.data) by an int &#160;factor." alt="" coords="251,885,914,905"/>
<area shape="rect" id="node4" href="pyto.segmentation.labels.Labels-class.html" title="This class concerns an integer&#45;labeled image that contains one or more segments." alt="" coords="239,477,925,911"/>
</map>
  <img src="uml_class_diagram_for_pyto_seg_3.gif" alt='' usemap="#uml_class_diagram_for_pyto_seg_3" ismap="ismap" class="graph-without-title" />
</center>
</center>
<hr />
<p>Important attributes:</p>
  <ul>
    <li>
      data: (ndarray) labeled cleft and boundary regions
    </li>
    <li>
      cleftId/bound1Id/bound2Id: ids of cleft / boundary 1 / boundary 2, 
      each saved as an ndarray
    </li>
    <li>
      ids: all of the above ids
    </li>
  </ul>
  <p>Methods:</p>
  <ul>
    <li>
      makeLayers(): makes layers in the cleft and possibly over boundaries
    </li>
    <li>
      getWidth(): calculates width and the orientation of the cleft
    </li>
    <li>
      getBoundaryDistances(): for each boundary edge voxel, finds the 
      position and the distance to closest voxel on the other boundary
    </li>
    <li>
      parametrizeLabels(): puts a coordinate system on labels
    </li>
  </ul>

<!-- ==================== INSTANCE METHODS ==================== -->
<a name="section-InstanceMethods"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Instance Methods</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-InstanceMethods"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#__init__" class="summary-sig-name">__init__</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">cleftId</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">bound1Id</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">bound2Id</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">copy</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">clean</span>=<span class="summary-sig-default">False</span>)</span><br />
      Sets attributes from arguments.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.__init__">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="setCleftIds"></a><span class="summary-sig-name">setCleftIds</span>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">cleftId</span>,
        <span class="summary-sig-arg">bound1Id</span>,
        <span class="summary-sig-arg">bound2Id</span>)</span><br />
      Sets boundary, cleft and all ids as attributes, in addition to 
      whatever else super does.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.setCleftIds">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#getWidth" class="summary-sig-name">getWidth</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">mode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">median</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">toBoundary</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">maxDistance</span>=<span class="summary-sig-default">None</span>)</span><br />
      Calculates the width and the orientation of the cleft (direction of 
      the width vector).</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.getWidth">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#getBoundaryDistances" class="summary-sig-name">getBoundaryDistances</a>(<span class="summary-sig-arg">self</span>)</span><br />
      For each boundary element contacting cleft (boundary edge), finds the
      position of the closest element on the other boundary and calculates 
      the distance between them.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.getBoundaryDistances">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#makeLayers" class="summary-sig-name">makeLayers</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">nLayers</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">width</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">widthMode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">median</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">maxDistance</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">fill</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">nExtraLayers</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">extra_1</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">extra_2</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">offset</span>=<span class="summary-sig-default">0.5</span>)</span><br />
      Makes cleft and boundary layers.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.makeLayers">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#adjustToRegions" class="summary-sig-name">adjustToRegions</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">regions</span>,
        <span class="summary-sig-arg">ids</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">value</span>=<span class="summary-sig-default">0</span>)</span><br />
      Adjusts self.data to correspond to regions.data.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.adjustToRegions">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#makeColumns" class="summary-sig-name">makeColumns</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">bins</span>,
        <span class="summary-sig-arg">ids</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">system</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">radial</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">normalize</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">originMode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">one</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">startId</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">metric</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">euclidean</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">connectivity</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">rimId</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">rimLocation</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">out</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">rimConnectivity</span>=<span class="summary-sig-default">1</span>)</span><br />
      Segments cleft to columns, that is segments perpendicular to cleft 
layers.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.makeColumns">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#parametrizeLayers" class="summary-sig-name">parametrizeLayers</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">ids</span>,
        <span class="summary-sig-arg">system</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">radial</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">normalize</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">originMode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">one</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">startId</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">metric</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">euclidean</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">connectivity</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">rimId</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">rimLocation</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">out</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">rimConnectivity</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">noDistance</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Parametrizes layers, that is puts a coordinate system on layer-like
segments.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.parametrizeLayers">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#pickCenter" class="summary-sig-name">pickCenter</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">id_</span>,
        <span class="summary-sig-arg">distance</span>,
        <span class="summary-sig-arg">fromPosition</span>=<span class="summary-sig-default">None</span>)</span><br />
      Returns coordinates of the center of segment specified by arg id_.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.pickCenter">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#pickLayerCenters" class="summary-sig-name">pickLayerCenters</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">ids</span>,
        <span class="summary-sig-arg">distance</span>,
        <span class="summary-sig-arg">mode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">one</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">startId</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">notFound</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">previous</code><code class="variable-quote">'</code></span>)</span><br />
      Returns coordinates of 'centers'of all segments specified by arg ids.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.pickLayerCenters">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code><a href="pyto.segmentation.segment.Segment-class.html">segment.Segment</a></code></b>:
      <code><a href="pyto.segmentation.segment.Segment-class.html#add">add</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#clean">clean</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#distanceFromOrigin">distanceFromOrigin</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#distanceToRegion">distanceToRegion</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#elementDistanceToRegion">elementDistanceToRegion</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#elementDistanceToRim">elementDistanceToRim</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#elementGeodesicDistanceToRegion">elementGeodesicDistanceToRegion</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#fillSegments">fillSegments</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#findNonUnique">findNonUnique</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#generateNeighborhoods">generateNeighborhoods</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#getStructureFootprint">getStructureFootprint</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#keep">keep</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#labelInteriors">labelInteriors</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#makeFree">makeFree</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#makeLayersBetween">makeLayersBetween</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#makeLayersFrom">makeLayersFrom</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#makeSurfaces">makeSurfaces</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#markDistance">markDistance</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#pairwiseDistance">pairwiseDistance</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#parseInput">parseInput</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#remove">remove</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#removeIdFromBound">removeIdFromBound</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#reorder">reorder</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#setData">setData</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#setDefaults">setDefaults</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#setProperties">setProperties</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#setSurfaceStructEl">setSurfaceStructEl</a></code>,
      <code><a href="pyto.segmentation.segment.Segment-class.html#shiftIds">shiftIds</a></code>
      </p>
    <p class="indent-wrapped-lines"><b>Inherited from <code><a href="pyto.segmentation.labels.Labels-class.html">labels.Labels</a></code></b>:
      <code><a href="pyto.segmentation.labels.Labels-class.html#extractIds">extractIds</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#findInset">findInset</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#getContactStructEl">getContactStructEl</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#getContactStructElConn">getContactStructElConn</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#getCountStructEl">getCountStructEl</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#getCountStructElConn">getCountStructElConn</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#getMaxId">getMaxId</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#getPoints">getPoints</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#getPointsGeodesic">getPointsGeodesic</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#magnify">magnify</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#makeInset">makeInset</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#orderByBoundaries">orderByBoundaries</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#orderByValues">orderByValues</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#orderIdsByBoundaries">orderIdsByBoundaries</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#orderIdsByValues">orderIdsByValues</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#restrict">restrict</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#setContactStructElConn">setContactStructElConn</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#setCountStructElConn">setCountStructElConn</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#setIds">setIds</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#setMaxId">setMaxId</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#setStructEl">setStructEl</a></code>
      </p>
    <div class="private">    <p class="indent-wrapped-lines"><b>Inherited from <code><a href="pyto.segmentation.labels.Labels-class.html">labels.Labels</a></code></b> (private):
      <code><a href="pyto.segmentation.labels.Labels-class.html#_remove" onclick="show_private();">_remove</a></code>
      </p></div>
    <p class="indent-wrapped-lines"><b>Inherited from <code><a href="pyto.core.image.Image-class.html">core.image.Image</a></code></b>:
      <code><a href="pyto.core.image.Image-class.html#absoluteToRelativeInset">absoluteToRelativeInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#clearFull">clearFull</a></code>,
      <code><a href="pyto.core.image.Image-class.html#copyPositioning">copyPositioning</a></code>,
      <code><a href="pyto.core.image.Image-class.html#expandInset">expandInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#findEnclosingInset">findEnclosingInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#findIntersectingInset">findIntersectingInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getDataInset">getDataInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getDeepBase">getDeepBase</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getFullData">getFullData</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getFullInset">getFullInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getInset">getInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getNdim">getNdim</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getOffset">getOffset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#getTotalOffset">getTotalOffset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#hasOverlap">hasOverlap</a></code>,
      <code><a href="pyto.core.image.Image-class.html#isInside">isInside</a></code>,
      <code><a href="pyto.core.image.Image-class.html#newFromInset">newFromInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#recoverFull">recoverFull</a></code>,
      <code><a href="pyto.core.image.Image-class.html#relativeToAbsoluteInset">relativeToAbsoluteInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#saveFull">saveFull</a></code>,
      <code><a href="pyto.core.image.Image-class.html#setDataInset">setDataInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#setFullData">setFullData</a></code>,
      <code><a href="pyto.core.image.Image-class.html#setFullInset">setFullInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#setInset">setInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#setNdim">setNdim</a></code>,
      <code><a href="pyto.core.image.Image-class.html#setOffset">setOffset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#tile">tile</a></code>,
      <code><a href="pyto.core.image.Image-class.html#useInset">useInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#usePositioning">usePositioning</a></code>,
      <code><a href="pyto.core.image.Image-class.html#write">write</a></code>
      </p>
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__delattr__</code>,
      <code>__format__</code>,
      <code>__getattribute__</code>,
      <code>__hash__</code>,
      <code>__new__</code>,
      <code>__reduce__</code>,
      <code>__reduce_ex__</code>,
      <code>__repr__</code>,
      <code>__setattr__</code>,
      <code>__sizeof__</code>,
      <code>__str__</code>,
      <code>__subclasshook__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== CLASS METHODS ==================== -->
<a name="section-ClassMethods"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Class Methods</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-ClassMethods"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pyto.segmentation.cleft.Cleft-class.html#read" class="summary-sig-name">read</a>(<span class="summary-sig-arg">cls</span>,
        <span class="summary-sig-arg">cleftId</span>,
        <span class="summary-sig-arg">bound1Id</span>,
        <span class="summary-sig-arg">bound2Id</span>,
        <span class="summary-sig-arg">file</span>,
        <span class="summary-sig-arg">clean</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">byteOrder</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dataType</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">arrayOrder</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">shape</span>=<span class="summary-sig-default">None</span>)</span><br />
      Reads segmented image (label filed) from a file and sets required 
      ids.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.read">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== CLASS VARIABLES ==================== -->
<a name="section-ClassVariables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Class Variables</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-ClassVariables"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
  <tr>
    <td colspan="2" class="summary">
    <div class="private">    <p class="indent-wrapped-lines"><b>Inherited from <code><a href="pyto.segmentation.segment.Segment-class.html">segment.Segment</a></code></b> (private):
      <code><a href="pyto.segmentation.segment.Segment-class.html#_remove_or_keep_factor" onclick="show_private();">_remove_or_keep_factor</a></code>
      </p></div>
    </td>
  </tr>
</table>
<!-- ==================== PROPERTIES ==================== -->
<a name="section-Properties"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Properties</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Properties"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code><a href="pyto.segmentation.labels.Labels-class.html">labels.Labels</a></code></b>:
      <code><a href="pyto.segmentation.labels.Labels-class.html#contactStructEl">contactStructEl</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#contactStructElConn">contactStructElConn</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#countStructEl">countStructEl</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#countStructElConn">countStructElConn</a></code>,
      <code><a href="pyto.segmentation.labels.Labels-class.html#maxId">maxId</a></code>
      </p>
    <p class="indent-wrapped-lines"><b>Inherited from <code><a href="pyto.core.image.Image-class.html">core.image.Image</a></code></b>:
      <code><a href="pyto.core.image.Image-class.html#fullData">fullData</a></code>,
      <code><a href="pyto.core.image.Image-class.html#fullInset">fullInset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#inset">inset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#ndim">ndim</a></code>,
      <code><a href="pyto.core.image.Image-class.html#offset">offset</a></code>,
      <code><a href="pyto.core.image.Image-class.html#totalOffset">totalOffset</a></code>
      </p>
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__class__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== METHOD DETAILS ==================== -->
<a name="section-MethodDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Method Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-MethodDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="__init__"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">__init__</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">cleftId</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">bound1Id</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">bound2Id</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">copy</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">clean</span>=<span class="sig-default">False</span>)</span>
    <br /><em class="fname">(Constructor)</em>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.__init__">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Sets attributes from arguments.</p>
  <p>Each of the id args (cleftId, bound1Id, bound2Id) can be a single int 
  or a list (array) in which cases a (boundary or cleft) is formed form all
  specified ids.</p>
  <p>Arguments:</p>
  <ul>
    <li>
      data: ndarray with labeled cleft and boundary regions
    </li>
    <li>
      bound1Id, bound2Id, cleftId: ids of boundaries 1, 2 and cleft
    </li>
    <li>
      copy: flag indicating if data array is copied
    </li>
    <li>
      clean: flag indicating if segmentss other than those specified by 
      boundary and cleft ids are removed from tha data array
    </li>
  </ul>
  <dl class="fields">
    <dt>Overrides:
        object.__init__
    </dt>
  </dl>
</td></tr></table>
</div>
<a name="getWidth"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">getWidth</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">mode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">median</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">toBoundary</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">maxDistance</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.getWidth">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Calculates the width and the orientation of the cleft (direction of 
  the width vector).</p>
  <p>The width is calculated by taking into account only the regions of the
  two boundaries that border the cleft region. First, min distance to the 
  boundary specified by toBoundary is calculated for each element of a 
  border region of the other boundary. Distance between boundaries is then 
  obtained as the mean/median/min/max (depending on the arg mode) of the 
  distances for each element. Finally, the cleft width is distance between 
  boundaries - 1. For example, if boundaries touch exch other the distance 
  between them is 1 and the cleft width is 0.</p>
  <p>If toBoundary=0, distances to both boundaries are calculated and the 
  width is obtained from all those distances taken together.</p>
  <p>The distance vector is calculated in a similar way, except that 
  distance vectors are calculated (instead of distances alone) and that the
  average vector is returned. I toBoundary is 1 or 2, average of the 
  distance vectors to boundary 1 or 2 is returned. If toBoundary is 0, 
  distance vectors are combined and then averaged. In any case, the 
  distance vector is oriended from boundary 1 (self.bound1Id) to boundary 2
  (self.bound2Id).</p>
  <p>If arg maxDistance is specified, only those elements of boundaries 
  borders (boundary elemnts that touch the cleft) whose distance to the 
  other boundary is not larger than maxDistance are taken into account. 
  Note that arg MaxDistance here has different meaning from the one in 
  Segment.makeLayersBetween().</p>
  <p>Argument:</p>
  <ul>
    <li>
      mode: cleft width calculating mode, 'mean', 'median', 'min' or 'max' 
      (actually can be any appropriate numpy function)
    </li>
    <li>
      toBoundary: distances calculated to that boundary
    </li>
    <li>
      maxDistance: max distance between boundaries
    </li>
  </ul>
  <p>Returns (width, width_vector) where:</p>
  <ul>
    <li>
      width: cleft width calculated between boundary edges, that is if the 
      boundaries touch each other the width is 0
    </li>
    <li>
      width_vector: (..geometry.Vector) average distance vector
    </li>
  </ul>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="getBoundaryDistances"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">getBoundaryDistances</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.getBoundaryDistances">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>For each boundary element contacting cleft (boundary edge), finds the 
  position of the closest element on the other boundary and calculates the 
  distance between them.</p>
  <p>Uses the smallest inset of the data array to speed up the 
  calculations. However, positions calculated are adjusted for self.inset, 
  that is they are given in respect to the fully expanded self.data.</p>
  <p>Used to provide info to higher level methods that deal with distances 
  between boundaries, such as self.getWidth().</p>
  <p>Return tuple containing the following ndarrays:</p>
  <ul>
    <li>
      distance to boundary 1 from each element of the edge of boundary 2
    </li>
    <li>
      positions of elements of boundary 1 found above
    </li>
    <li>
      positions of edge elements of boundary 2
    </li>
    <li>
      distance to boundary 2 from each element of the edge of boundary 1
    </li>
    <li>
      positions of elements of boundary 2 found above
    </li>
    <li>
      positions of edge elements of boundary 1
    </li>
  </ul>
  <p>The first (last) three are indexed in the same way, that is according 
  to the the boundary 2 (boundary 1) edge elements. Positions are returned 
  in the form numpy uses for coordinates, that is as a list where element i
  contains array of coordinates along axis i.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="makeLayers"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">makeLayers</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">nLayers</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">width</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">widthMode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">median</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">maxDistance</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">fill</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">nExtraLayers</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">extra_1</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">extra_2</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">offset</span>=<span class="sig-default">0.5</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.makeLayers">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Makes cleft and boundary layers.</p>
  <p>Attributes self.bound1Id, self.bound2Id and self.cleftId (defining 
  boundaries and the cleft region, respectively) need to be set. Cleft 
  layers can be formed on (is a subset of) the cleft region only, while the
  boundary layers are formed on boundaries and extra regions (subset 
  again).</p>
  <p>If arg width is None, the cleft width is calculated using 
  self.getWidth(toBoundary=0). In short, for each element of boundary 
  borders (elements of boundaries that contact the cleft region) the 
  shortest distance to the other boundary is calculated. The distances 
  greater than arg maxDistance are not taken into account, The 
  mean/median/min/max (according to the argument widthMode) of these values
  -1 is then cleft width calculated edge-to-edge. Strictly speaking, 
  subtracting 1 is valid for relatively flat cleft. The only reason for 
  specifying arg width as an argument is to avoid computing it twice.</p>
  <p>Number of layers is the rounded value of the cleft width.</p>
  <p>The layers are then made using Segment.makeLayersBetween() (see for 
  more detailed info). If there is no extra layers (nExtraLayers=0) layers 
  of approximatelly same thickness are positioned parallel to the boundary 
  borders. Specifically, layers are calculated as:</p>
  <p>layer_no = floor{(d_1 - offset) * nLayers / (d_1 + d_2 - 2*offset) + 
  1}</p>
  <p>where d_1 and d_2 are the shortest distances to borders of boundary 1 
  and 2. Layers are made only in the cleft region.</p>
  <p>If arg maxDistance is specified, the cleft region is restricted to 
  those elements that have sum of distances to both boundaries &lt;= 
  maxDistance. If arg fill is True the holes created by the restriction to 
  maxDistance are filled.</p>
  <p>Number of layers is either given by arg nLayers (in which case layer 
  thcikness is cleft_width / nLayers) or it equals the cleft width 
  (thickness = 1).</p>
  <p>In case nExtraLayers is &gt; 0, extra layers are formed in addition to
  the cleft layers (explained above). The extra layers are formed on the 
  boundaries and on the extra regions (args extra_1 and extra_2). The extra
  layers are formed based on their euclidean distance to the closest cleft 
  layer, and they have the same thickness as the cleft layers. This is done
  using Segment.makeLayersFrom() method. The additional layers formed over 
  the first boundary and the first extra region are numbered from 1 to 
  nExtraLayers, the ids of the cleft layers are shifted by nExtraLayers and
  the layers formed over the second boundary and the second extra region go
  from nLayers_nExtraLayers+1 to nLayers+2*nExtraLayers.</p>
  <p>The layers are returned as a Segment object, where layers.data is an 
  array that contains all layers. Layers.data can have smaller shape than 
  self.data, and layers.offset is set appropriatelly. To be precise, 
  layers.data is just big enough to contain all layers as well as regions 
  occupied by boundaries.</p>
  <p>Arguments:</p>
  <ul>
    <li>
      nLayers: number of layers, in None 1-pixel thick layers are formed
    </li>
    <li>
      width: cleft width, calculated if None
    </li>
    <li>
      widthMode: cleft width calculation mode ('mean', 'median', 'min', 
      'max', or any appropriate numpy function), used only if width is None
    </li>
    <li>
      maxDistance: max allowed sum of (minimal) distances to the two 
      boundaries, if None no limit is imposed
    </li>
    <li>
      fill: flag indicating if holes created by maxDistance procedure are 
      filled (used only if maxDistance is not None)
    </li>
    <li>
      nExtraLayers: (int) number of additional layers formed on each side 
      of the cleft
    </li>
    <li>
      extra_1, extra_2: (int, or a list of int's) ids of extra regions 1 
      and 2 respectivly
    </li>
    <li>
      offset: numerical parameter that compensates for the disccrete nature
      of distances, should be 0.5
    </li>
  </ul>
  <p>Returns: layers, width</p>
  <ul>
    <li>
      layers: (Segment) layers
    </li>
    <li>
      width: cleft width
    </li>
  </ul>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="adjustToRegions"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">adjustToRegions</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">regions</span>,
        <span class="sig-arg">ids</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">value</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.adjustToRegions">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Adjusts self.data to correspond to regions.data.</p>
  <p>Sets elements of self.data that have one of the specified ids and that
  correspond at 0-elements of arg regions to arg value.</p>
  <p>If arg ids is None, any element of self.data can be set to arg 
  value.</p>
  <p>Arguments:</p>
  <ul>
    <li>
      regions: (Segment) regions
    </li>
    <li>
      ids: list of ids of this instance where self.data can be adjusted
    </li>
    <li>
      value: value to be adjusted to
    </li>
  </ul>
  <p>Modifies self.data.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="makeColumns"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">makeColumns</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">bins</span>,
        <span class="sig-arg">ids</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">system</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">radial</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">normalize</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">originMode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">one</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">startId</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">metric</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">euclidean</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">connectivity</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">rimId</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">rimLocation</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">out</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">rimConnectivity</span>=<span class="sig-default">1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.makeColumns">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Segments cleft to columns, that is segments perpendicular to cleft 
layers. 

The attribute data of this instance needs to contain layers, preferably 
of thickness 1. This can be done using makeLayers(nLayers=None).

First, the layers are parametrized, that is layer centers are determined
(see parametrizeLayers() and pickCenter()) and then a coordinate system
with origin at the layer center is placed on each of the layers 
according to args system and metric (see self.parametrizeLayers() for 
details). 

If arg normalize is False, each layer element is assigned a value
that equals its distance to the center. Alternatively, if normalize
is True and a radial distance need to be calculated (system 'radial' or
'polar'), radial values assigned to layer elements are caluclated as:

    distance_to_center / (distance_to_center + min_distance_to_rim)

where min_distance_to_rim is the shortest distance to rim which 
surrounds layers. Consequently, center gets value of 0 and layer
elements that contact the rim are assigned value 1. 

Then, each layer element is assigned to a segment based on its
parametrization and arg bins (see Grey.labelByBins() for details). The
arg bins can contain one set of binning values for each of the 
coordinates of the specified coordinate system. If bins are not given 
for all coordinates, those at the end are ignored. For example, given:

  bin=[[0,2,4], [-pi, 0, pi]], system='polar'

in 3D, rho coordinate is binned according to [0,2,4], phi according
to [-pi, 0, pi] and z is disregarded (the order of coordinates in the
polar system is: rho, phi, z).

Lower bin limits are inclsive, while the upper are exclusive except for
the last one which is inclusive.

Non-asigned array elements are set to 0. The resulting segmented image 
is converted to a Segmentation object that has the same positioning 
as this instance.

For example, if self.data is:

    [[5, 5, 5, 5, 5, 5],
     [5, 1, 1, 1, 5, 5],
     [5, 1, 1, 1, 5, 5],
     [5, 1, 1, 1, 5, 5], 
     [5, 1, 1, 1, 5, 5],
     [5, 1, 1, 1, 5, 5],
     [5, 1, 1, 1, 5, 5],
     [5, 1, 1, 1, 5, 5],
     [5, 5, 5, 5, 5, 5]])

self.makeColumns(
    ids=[1], system='radial', normalize=False, startId=1, 
    metric='euclidean', connectivity=1, rimId=5, bins=[0, 1, 2, 3, 4])

will return:

    [[0, 0, 0, 0, 0, 0],
     [0, 4, 4, 4, 0, 0],
     [0, 3, 3, 3, 0, 0],
     [0, 2, 2, 2, 0, 0],
     [0, 2, 1, 2, 0, 0],
     [0, 2, 2, 2, 0, 0],
     [0, 3, 3, 3, 0, 0],
     [0, 4, 4, 4, 0, 0],
     [0, 0, 0, 0, 0, 0]])

while: 

self.makeColumns(
    ids=[1], system='radial', normalize=False, startId=1, 
    metric='euclidean', connectivity=1, rimId=5, bins=[0, 2, 4])

will return:

    [[0, 0, 0, 0, 0, 0],
     [0, 2, 2, 2, 0, 0],
     [0, 2, 2, 2, 0, 0],
     [0, 1, 1, 1, 0, 0],
     [0, 1, 1, 1, 0, 0],
     [0, 1, 1, 1, 0, 0],
     [0, 2, 2, 2, 0, 0],
     [0, 2, 2, 2, 0, 0],
     [0, 0, 0, 0, 0, 0]])

Arguments:
  - bins: binning values
  - ids: ids of layer where columns are made
  - system: coordinate syatem, can be 'radial', 'cartesian' or 'polar'
  - normalize: flag indicating if radial distance is normalized
  - metric: distance metric, can be 'euclidean', 'geodesic' or
  'euclidean-geodesic'
  - connectivity: connectivity of the structure element (as in
scipy.ndimage.generate_binary_structure() where rank is self.ndim)
for geodesic distance calculation (int). Not used for euclidean.
  - originMode: determines how centers are determined, currently only 
  'one' (see self.pickLayerCenters())
  - startId: layer where the center is first determined, used in mode 
  'one', None means start from the middle (see self.pickLayerCenters())
  - rimId: id or rim region
  - rimLocation: specifies if the rim is just outside of layers
  ('out') or on the layer boundary ('in')
  - rimConnectivity: (int) connectivity of the structure element
  that defines contact elements between a layer and the rim region.

Returns column-segmented cleft as an instance of Segment where:
  - column.data: (ndarray) labeled array
  - column,binIds: (dict) where each id is a key and the corresponding 
  value is a list of lower and uper bin limits for each binning.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="parametrizeLayers"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">parametrizeLayers</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">ids</span>,
        <span class="sig-arg">system</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">radial</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">normalize</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">originMode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">one</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">startId</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">metric</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">euclidean</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">connectivity</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">rimId</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">rimLocation</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">out</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">rimConnectivity</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">noDistance</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.parametrizeLayers">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Parametrizes layers, that is puts a coordinate system on layer-like
segments. As a result, each element of self.data that belongs to one of 
the layers (specified by arg ids) is associated with one or more
coordinates of the new system.

Radial coordinate is calculated as the distance of each layer element
to the origin of that layer, using the specified distance metric. The 
origin of a layer is an element that has the largest distance to the 
rim surrounding the layer. In case there's more than one element having 
the largest distance, the element closest to the layer center of mass 
is chosen. See self.elementDistanceToRim() and self.pickLayerCenters()
for the origin determination and self.distanceFromOrigin() for the
distance from origin.

If arg normalize is False, each layer element is assigned a value
that equals its distance to the center. Alternatively, if normalize
is True, the values assigned to layer elements is caluclated as:

    distance_to_center / (distance_to_center + min_distance_to_rim)

where min_distance_to_rim is the shortest distance to rim which 
surrounds layers. Consequently, center gets value of 0 and layer
elements that contact the rim are assigned value 1. 

In 2D and &gt;3D only the radial parametrization is possible.

To calculate cartesian coordinates in 3D the layers are rotated so that
the vector perpendicular to layers (actually the best fit line for all
layer origins) is aligned with the z-axis (theta=0), and that that the 
direction towards the lowest z-postions of the original layers is 
aligned with the x-axis (phi=0). The origin of this rotation is the 
layer center, so this rotation is repeated for each layer separately. 
The coordinates of the rotated cleft are taken as the cartesian 
parametrization of the cleft. 

If the metric is euclidean for 3D cartesian system, the 
coordinates of the rotated cleft are the calculated coordinates. In
addition, z coordinate is calculated in repect to the layer center
(just like x and y). Also, it is not defined if layer ids increase 
along positive or negative z-axis.

Alternatively, if the metric is geodesic for 3D cartesian system,
first the polar coordinate phi is calculated and the x and y 
coordinates are calculated from the radial and phi coordinate. In
this case z coordinate is not calculated (nor returned).

Layers of this instance should be thin (of thickness 1 or so), so that
center of each layer borders layers on both sides.

Polar coordinates can be used in 3D. The angle (phi) is calculated from
the cartesian coordinates (x and y). The radial coordinate calculated as
explained above and the z coordinate from the cartesian coordinates
complete the system.

Arguments:
  - ids: layer ids
  - system: coordinate syatem, can be 'radial', 'cartesian' or 'polar'
  - normalize: flag indicating if radial distance is normalized
  - metric: distance metric, can be 'euclidean', 'geodesic' or
  'euclidean-geodesic'
  - connectivity: connectivity of the structure element (as in
scipy.ndimage.generate_binary_structure() where rank is self.ndim)
for geodesic distance calculation (int). Not used for euclidean.
  - originMode: determines how centers are determined, currently only 
  'one' (see self.pickLayerCenters())
  - startId: layer where the center is first determined, used in mode 
  'one', None means start from the middle (see self.pickLayerCenters())
  - rimId: id or rim region
  - rimLocation: specifies if the rim is just outside of layers
  ('out') or on the layer boundary ('in')
  - rimConnectivity: (int) connectivity of the structure element
  that defines contact elements between a layer and the rim region.
  - noDistance: value used for array elements where the distance is
  not calculated

Returns: masked ndarray where axis 0 denotes a coordinate and the other
dimensions are the same as those of self.data. Elements outside the
layers are masked. The coordinates returned depend on the coordinate 
system (arg system):
  - radial: rho
  - cartesian (3D only): [x, y, z]
  - polar (3D only): [rho, phi, z]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pickCenter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pickCenter</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">id_</span>,
        <span class="sig-arg">distance</span>,
        <span class="sig-arg">fromPosition</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.pickCenter">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns coordinates of the center of segment specified by arg id_. 
  Center is defined as the point that has the highest distance (to the rim 
  of the segment). Distances of all points are specified by arg 
  distance.</p>
  <p>If arg fromPosition is None, the position of global maximum of the 
  specified segment is returned.</p>
  <p>Alternatively, if arg fromPosition is a coordinate, the position of 
  maximum on the specified segment within the neighborhood of the arg 
  fromPosition (both rank and connectivity of the structure element are 
  self.ndim). If no element with the specified id exists in the 
  neighborhood of fromPosition, None is returned.</p>
  <p>If more than one max position exist, the one closest to the center of 
  mass of the whole segment (having id_) is chosen. If multiple (min 
  position to cm) exist, one of them is chosen randomly (calculated by 
  scipy.ndimage.minimum_position).</p>
  <p>Arguments:</p>
  <ul>
    <li>
      id_: segment id
    </li>
    <li>
      distance: (ndarray of the same shape as self.data) distances
    </li>
    <li>
      fromPosition: (1d ndarray) coordinates of a point in the neighborhood
      of or on the specified segment
    </li>
  </ul>
  <p>Returns: (1d ndarray) coordinates of max position</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pickLayerCenters"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pickLayerCenters</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">ids</span>,
        <span class="sig-arg">distance</span>,
        <span class="sig-arg">mode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">one</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">startId</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">notFound</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">previous</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.pickLayerCenters">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns coordinates of 'centers'of all segments specified by arg 
  ids.</p>
  <p>If arg mode is 'one', it starts by finding the max position (center) 
  on the distance array (arg distance) on the segment specified by arg 
  startId. Afterwards, the center determination proceeds to neighboring 
  segments according to the positioning of ids in arg ids, in both 
  ascending (to the right) and descending (to the left) order. The center 
  of a next layer is determined as the max distance on the region of the 
  next layer that is within the neighborhood of the previous center. The 
  neighborhood of an element is defined as all elements that have at least 
  a vertex in common. If no layer element is found within the neighborhood,
  the center of that layer is set to None (arg notFound is None) or to the 
  previous layer center (arg notFound is 'previous').</p>
  <p>It is necessary that segments are organized as thin layers, so that a 
  center of each layer always lies in a neighborhood of the layers that are
  next to it. Layers of thickness 1 most likely satisfy this condition.</p>
  <p>Max positions are calculated by self.pickCenter, that in turn calls 
  scipy.ndimage.maximum_position, which returns only one value if multiple 
  max points exist.</p>
  <p>Arguments:</p>
  <ul>
    <li>
      id_: segment id
    </li>
    <li>
      distance: (ndarray of the same shape as self.data) distances
    </li>
    <li>
      mode: determines how centers are determined, currently only 'one'
    </li>
    <li>
      startId: Segment layer where the center is first determined, used in 
      mode 'one', None means start from the middle
    </li>
    <li>
      notFound: determines the returned value for layers whose center 
      wasn't found
    </li>
  </ul>
  <p>Returns: (dict) of coordinates, where keys are ids and values are (1d 
  ndarray) coordinates of centers, or None if the center was not found.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="read"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">read</span>(<span class="sig-arg">cls</span>,
        <span class="sig-arg">cleftId</span>,
        <span class="sig-arg">bound1Id</span>,
        <span class="sig-arg">bound2Id</span>,
        <span class="sig-arg">file</span>,
        <span class="sig-arg">clean</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">byteOrder</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dataType</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">arrayOrder</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">shape</span>=<span class="sig-default">None</span>)</span>
    <br /><em class="fname">Class Method</em>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="pyto.segmentation.cleft-pysrc.html#Cleft.read">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Reads segmented image (label filed) from a file and sets required 
  ids.</p>
  <p>Each of the id args (cleftId, bound1Id, bound2Id) can be a single int 
  or a list (array) in which cases a (boundary or cleft) is formed form all
  specified ids.</p>
  <p>If file is in em or mrc format (file extension em or mrc) only the 
  file argument is needed. If the file is in the raw data format (file 
  extension raw) all arguments are required.</p>
  <p>Arguments:</p>
  <ul>
    <li>
      bound1Id, bound2Id, cleftId: ids of boundaries 1, 2 and cleft
    </li>
    <li>
      file: file name
    </li>
    <li>
      clean: if true, only the segments corresponding to ids are kept
    </li>
    <li>
      byteOrder: '&lt;' (little-endian), '&gt;' (big-endian)
    </li>
    <li>
      dataType: any of the numpy types, e.g.: 'int8', 'int16', 'int32', 
      'float32', 'float64'
    </li>
    <li>
      arrayOrder: 'C' (z-axis fastest), or 'FORTRAN' (x-axis fastest)
    </li>
    <li>
      shape: (x_dim, y_dim, z_dim)
    </li>
  </ul>
  <p>Returns:</p>
  <ul>
    <li>
      instance of Segment
    </li>
  </ul>
  <dl class="fields">
    <dt>Overrides:
        <a href="pyto.core.image.Image-class.html#read">core.image.Image.read</a>
    </dt>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pyto-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            >Pyto</th>
          </tr></table></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1
    on Thu Nov  8 16:54:04 2018
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
